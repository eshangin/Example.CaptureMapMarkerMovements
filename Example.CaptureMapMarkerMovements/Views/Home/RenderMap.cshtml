@model IEnumerable<Example.CaptureMapMarkerMovements.Models.Waypoint>

@{
    ViewBag.Title = "Home Page";
    Layout = null;
    string jsonData = Newtonsoft.Json.JsonConvert.SerializeObject(Model);
}

<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://openlayers.org/en/v5.3.0/css/ol.css" type="text/css">
    <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.3.0/build/ol.js"></script>
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
</head>
<body>

    <div id="map" class="map" style="width: 1000px; height: 600px;"></div>
    <div id="completestate" style="display:none">not started</div>
    <div id="input-data" style="display:none">@jsonData</div>

    <script>        

        var inputData = JSON.parse(document.getElementById('input-data').innerText);

        var wp = [];
        for (var i = 0; i < inputData.length; i++) {
            wp.push([inputData[i].Lng, inputData[i].Lat]);
        }

        for (var i = 0; i < wp.length; i++) {
            wp[i] = ol.proj.fromLonLat(wp[i]);
        }

        var wpfeatureLine = new ol.Feature({
            geometry: new ol.geom.LineString(wp),
            name: 'ABC Line'
        });

        var wpline = new ol.source.Vector({});

        //Add point feature for every coordinate
        for (var i = 0; i < wp.length; i++) {
            var pointFeature = new ol.Feature({
                geometry: new ol.geom.Point(wp[i]),
                name: 'XYZ' + i
            });
            wpline.addFeature(pointFeature);
        }

        //wpfeatureLine.setStyle(); You can add your custom style definition here.
        wpline.addFeature(wpfeatureLine); //lined or a way point feature on map

        var vectorLineLayer = new ol.layer.Vector({
            source: wpline
            //Remove any style, Default style will be used
        });

        var geoMarker = new ol.Feature({
            type: 'geoMarker',
            geometry: new ol.geom.Point(wp[0])
        });
        //var startMarker = new ol.Feature({
        //    type: 'icon',
        //    geometry: new ol.geom.Point(routeCoords[0])
        //});
        //var endMarker = new ol.Feature({
        //    type: 'icon',
        //    geometry: new ol.geom.Point(routeCoords[routeLength - 1])
        //});

        var styles = {
            'route': new ol.style.Style({
                stroke: new ol.style.Stroke({
                    width: 6, color: [237, 212, 0, 0.8]
                })
            }),
            'icon': new ol.style.Style({
                image: new ol.style.Icon({
                    anchor: [0.5, 1],
                    src: 'data/icon.png'
                })
            }),
            'geoMarker': new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({ color: 'black' }),
                    stroke: new ol.style.Stroke({
                        color: 'white', width: 2
                    })
                })
            })
        };

        var view = new ol.View({
            center: wp[0],
            zoom: 10,
            minZoom: 2,
            maxZoom: 19
        });

        var key = 'AifUA41UximrujvNoJp15-yQsmBOattJxjecWXdsW4fzIDr14uBd0-xvZykxDoAq';

        //var tileSource = new ol.source.OSM();
        var tileSource = new ol.source.BingMaps({ key: key, imagerySet: 'Road' })
        var tileLayer = new ol.layer.Tile({
            source: tileSource
        });

        var map = new ol.Map({
            target: document.getElementById('map'),
            loadTilesWhileAnimating: true,
            view: view,
            layers: [
                tileLayer,
                //vectorLayer,
                vectorLineLayer
            ],
            controls: []
        });


        fitMap();

        var waypointsWithIntermidiate = [];
        var intermidiateWaypointsToOriginalData = {};

        calculateIntermidiatePoints();

        console.log('TOTAL WAYPOINTS', waypointsWithIntermidiate.length);

        var moveObjects = { index: 0 };

        var tilesState = {
            loaded: 0,
            total: 0
        };
        tileSource.on('tileloadstart', function () {
            tilesState.total++;
        });
        tileSource.on('tileloadend', function (a) {
            tilesState.loaded++;
            if (tilesState.loaded == tilesState.total) {
                console.log('all tiles loaded (' + tilesState.loaded + ')');
                startAnimation();
            }            
        });
        tileSource.on('tileloaderror', function (a, b) {
            console.log('tile load error', a, b);
        });

        //setInterval(function () {
        //    if (document.getElementById('completestate').innerHTML != 'yes') {
        //        moveMarker();
        //    }
        //}, 100);

        function moveMarker() {

            var waypoints = waypointsWithIntermidiate;

            if (moveObjects.vectorContext && moveObjects.frameState) {

                if (moveObjects.index >= waypoints.length) {
                    stopAnimation();
                    return;
                }

                var waypointCoords = waypoints[moveObjects.index];
                var currentPoint = new ol.geom.Point(waypointCoords);
                var feature = new ol.Feature(currentPoint);
                var text = intermidiateWaypointsToOriginalData[waypointCoords[0] + waypointCoords[1]].Speed;
                styles.geoMarker.setText(createTextStyle(text));
                moveObjects.vectorContext.drawFeature(feature, styles.geoMarker);

                moveObjects.index += 1;
            }
        }

        var moveFeature = function (event) {
            moveObjects.vectorContext = event.vectorContext;
            moveObjects.frameState = event.frameState;
        };

        function startAnimation() {
            document.getElementById('completestate').innerHTML = 'start';
            now = new Date().getTime();
            speed = 50;
            geoMarker.setStyle(null);

            map.on('postcompose', moveFeature);
            map.render();
        }

        function stopAnimation() {
            document.getElementById('completestate').innerHTML = 'yes';
            console.log('animation complete');

            //remove listener
            map.un('postcompose', moveFeature);
        }

        function fitMap() {
            var extent = {
                maxLng: Math.max.apply(null, wp.map(function (item) {
                    return item[0];
                })),
                minLng: Math.min.apply(null, wp.map(function (item) {
                    return item[0];
                })),
                maxLat: Math.max.apply(null, wp.map(function (item) {
                    return item[1];
                })),
                minLat: Math.min.apply(null, wp.map(function (item) {
                    return item[1];
                }))
            };
            view.fit([extent.minLng, extent.minLat, extent.maxLng, extent.maxLat]);
        }

        function distanceBetweenPoints(latlng1, latlng2) {
            var line = new ol.geom.LineString([latlng1, latlng2]);
            return line.getLength();
        };

        function createTextStyle(text) {
            return new ol.style.Text({
                textBaseline: 'middle',
                font: 'Arial',
                text: text,
                fill: new ol.style.Fill({ color: '#000000' }),
                offsetY: -15
            });
        };

        function calculateIntermidiatePoints() {
            var mapExtent = map.getView().calculateExtent(map.getSize());
            var mapDiagonalDistance = distanceBetweenPoints([mapExtent[0], mapExtent[1]], [mapExtent[2], mapExtent[3]]);

            var dotsPerOnePercentDistance = 1;
            for (var i = 1; i < wp.length; i++) {
                //console.log((distanceBetweenPoints(wp[i - 1], wp[i]) * 100 / mapDiagonalDistance) + ' %', Math.ceil((distanceBetweenPoints(wp[i - 1], wp[i]) * 100 / mapDiagonalDistance)));
                var wpDistToMapDistInPercents = Math.ceil((distanceBetweenPoints(wp[i - 1], wp[i]) * 100 / mapDiagonalDistance));

                // Push actual point
                waypointsWithIntermidiate.push(wp[i - 1]);
                pushIntermidiateWaypont(wp[i - 1], inputData[i - 1]);

                // Push itermidiate points
                var dotsPerCurrentPoints = dotsPerOnePercentDistance * wpDistToMapDistInPercents;
                for (var j = 1; j <= dotsPerCurrentPoints; j++) {
                    pushIntermidiateWaypont([
                        wp[i - 1][0] + (wp[i][0] - wp[i - 1][0]) * j / (dotsPerCurrentPoints + 1),
                        wp[i - 1][1] + (wp[i][1] - wp[i - 1][1]) * j / (dotsPerCurrentPoints + 1)
                    ], inputData[i - 1]);
                }

                if (i == wp.length - 1) {
                    waypointsWithIntermidiate.push(wp[i]);
                    pushIntermidiateWaypont(wp[i], inputData[i]);
                }
            }
        }

        function pushIntermidiateWaypont(coordinates, originalWaypointData) {
            waypointsWithIntermidiate.push(coordinates);
            intermidiateWaypointsToOriginalData[coordinates[0] + coordinates[1]] = originalWaypointData;
        }

    </script>
</body>
</html>
