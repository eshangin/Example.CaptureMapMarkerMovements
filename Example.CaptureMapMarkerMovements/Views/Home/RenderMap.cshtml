@model IEnumerable<Example.CaptureMapMarkerMovements.Models.Waypoint>

@{
    ViewBag.Title = "Home Page";
    Layout = null;
    string jsonData = Newtonsoft.Json.JsonConvert.SerializeObject(Model);
}

<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://openlayers.org/en/v5.3.0/css/ol.css" type="text/css">
    <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.3.0/build/ol.js"></script>
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
</head>
<body>

    <div id="map" class="map" style="width: 1000px; height: 600px;"></div>
    <div id="completestate" style="display:none">not started</div>
    <div id="input-data" style="display:none">@jsonData</div>

    <script>        

        var inputData = JSON.parse(document.getElementById('input-data').innerText);

        var wp = [];
        for (var i = 0; i < inputData.length; i++) {
            wp.push([inputData[i].Lng, inputData[i].Lat]);
        }

        for (var i = 0; i < wp.length; i++) {
            wp[i] = ol.proj.fromLonLat(wp[i]);
        }

        var wpfeatureLine = new ol.Feature({
            geometry: new ol.geom.LineString(wp),
            name: 'ABC Line'
        });

        var wpline = new ol.source.Vector({});

        //Add point feature for every coordinate
        for (var i = 0; i < wp.length; i++) {
            //wp[i] = ol.proj.fromLonLat(wp[i]);
            //coord = wp[i];
            //var coord = ol.proj.fromLonLat(wp[i]);
            var pointFeature = new ol.Feature({
                geometry: new ol.geom.Point(wp[i]),
                name: 'XYZ' + i
            });
            wpline.addFeature(pointFeature);
        }

        //wpfeatureLine.setStyle(); You can add your custom style definition here.
        wpline.addFeature(wpfeatureLine); //lined or a way point feature on map

        var vectorLineLayer = new ol.layer.Vector({
            source: wpline
            //Remove any style, Default style will be used
        });

        //var route = (new ol.format.Polyline({
        //    factor: 1e6
        //}).readGeometry(polyline, {
        //    dataProjection: 'EPSG:4326',
        //    featureProjection: 'EPSG:3857'
        //}));

        //var routeCoords = route.getCoordinates();
        //var routeLength = routeCoords.length;

        //var routeFeature = new ol.Feature({
        //    type: 'route',
        //    geometry: route
        //});
        var geoMarker = new ol.Feature({
            type: 'geoMarker',
            geometry: new ol.geom.Point(wp[0])
        });
        //var startMarker = new ol.Feature({
        //    type: 'icon',
        //    geometry: new ol.geom.Point(routeCoords[0])
        //});
        //var endMarker = new ol.Feature({
        //    type: 'icon',
        //    geometry: new ol.geom.Point(routeCoords[routeLength - 1])
        //});

        var styles = {
            'route': new ol.style.Style({
                stroke: new ol.style.Stroke({
                    width: 6, color: [237, 212, 0, 0.8]
                })
            }),
            'icon': new ol.style.Style({
                image: new ol.style.Icon({
                    anchor: [0.5, 1],
                    src: 'data/icon.png'
                })
            }),
            'geoMarker': new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({ color: 'black' }),
                    stroke: new ol.style.Stroke({
                        color: 'white', width: 2
                    })
                })
            })
        };

        var animating = false;
        var speed, now;
        var speedInput = document.getElementById('speed');
        var startButton = document.getElementById('start-animation');

        //var vectorLayer = new ol.layer.Vector({
        //    source: new ol.source.Vector({
        //        features: [routeFeature, geoMarker, startMarker, endMarker]
        //    }),
        //    style: function (feature) {
        //        // hide geoMarker if animation is active
        //        if (animating && feature.get('type') === 'geoMarker') {
        //            return null;
        //        }
        //        return styles[feature.get('type')];
        //    }
        //});

        var view = new ol.View({
            center: wp[0],
            zoom: 10,
            minZoom: 2,
            maxZoom: 19
        });

        var key = 'AifUA41UximrujvNoJp15-yQsmBOattJxjecWXdsW4fzIDr14uBd0-xvZykxDoAq';

        //var tileSource = new ol.source.OSM();
        var tileSource = new ol.source.BingMaps({ key: key, imagerySet: 'Road' })
        var tileLayer = new ol.layer.Tile({
            source: tileSource
        });

        var map = new ol.Map({
            target: document.getElementById('map'),
            loadTilesWhileAnimating: true,
            view: view,
            layers: [
                tileLayer,
                //vectorLayer,
                vectorLineLayer
            ],
            controls: []
        });


        fitMap();

        var waypointsWithIntermidiate = [];
        var intermidiateWaypointsToOriginalData = {};

        calculateIntermidiatePoints();

        function calculateIntermidiatePoints() {
            var mapExtent = map.getView().calculateExtent(map.getSize());
            var mapExtentLngLat = ol.proj.transformExtent(mapExtent, 'EPSG:3857', 'EPSG:4326');
            var mapDiagonalDistance = distanceBetweenPoints([mapExtent[0], mapExtent[1]], [mapExtent[2], mapExtent[3]]);
            console.log('MAP', mapExtent,
                mapExtentLngLat,
                mapDiagonalDistance);

            var minPointsDistanceData = {
                minLength: 10000000000000000,
                maxLength: 0
            };
            var dotsPerOnePercentDistance = 1;
            for (var i = 0; i < wp.length; i++) {
                //wp.push([inputData[i].Lng, inputData[i].Lat]);
                if (i > 0) {
                    minPointsDistanceData.minLength = Math.min(minPointsDistanceData.minLength, distanceBetweenPoints(wp[i - 1], wp[i]));
                    minPointsDistanceData.maxLength = Math.max(minPointsDistanceData.maxLength, distanceBetweenPoints(wp[i - 1], wp[i]));
                    console.log(minPointsDistanceData.minLength, minPointsDistanceData.maxLength,
                        (distanceBetweenPoints(wp[i - 1], wp[i]) * 100 / mapDiagonalDistance) + ' %', Math.ceil((distanceBetweenPoints(wp[i - 1], wp[i]) * 100 / mapDiagonalDistance)));
                    var wpDistToMapDistInPercents = Math.ceil((distanceBetweenPoints(wp[i - 1], wp[i]) * 100 / mapDiagonalDistance));
                    //waypointsWithIntermidiate

                    // Push actual point
                    waypointsWithIntermidiate.push(wp[i - 1]);
                    pushIntermidiateWaypont(wp[i - 1], inputData[i - 1]);

                    // Push itermidiate points
                    var dotsPerCurrentPoints = dotsPerOnePercentDistance * wpDistToMapDistInPercents;
                    for (var j = 1; j <= dotsPerCurrentPoints; j++) {
                        pushIntermidiateWaypont([
                            wp[i - 1][0] + (wp[i][0] - wp[i - 1][0]) * j / (dotsPerCurrentPoints + 1),
                            wp[i - 1][1] + (wp[i][1] - wp[i - 1][1]) * j / (dotsPerCurrentPoints + 1)
                        ], inputData[i - 1]);
                    }

                    if (i == wp.length - 1) {
                        waypointsWithIntermidiate.push(wp[i]);
                        pushIntermidiateWaypont(wp[i], inputData[i]);
                    }

                    //console.log(wp[i - 1], waypointsWithIntermidiate);
                }
            }

            for (var i = 0; i < wp.length; i++) {
                if (i > 0) {
                    var dotsBetweenWaypoints = Math.min(10, Math.ceil(distanceBetweenPoints(wp[i - 1], wp[i]) * 5 / minPointsDistanceData.minLength))
                    console.log('DOTS', dotsBetweenWaypoints);
                }
            }
        }

        function pushIntermidiateWaypont(coordinates, originalWaypointData) {
            waypointsWithIntermidiate.push(coordinates);
            intermidiateWaypointsToOriginalData[coordinates[0] + coordinates[1]] = originalWaypointData;
        }


        var tilesState = {
            loaded: 0,
            total: 0
        };
        tileSource.on('tileloadstart', function () {
            tilesState.total++;
            console.log('Tiles count: ' + tilesState.total);
        });
        tileSource.on('tileloadend', function (a) {
            tilesState.loaded++;
            if (tilesState.loaded == tilesState.total) {
                console.log('all tiles loaded');
                startAnimation();
            }            
        });
        tileSource.on('tileloaderror', function (a, b) {
            console.log('tile load error', a, b);
        });
        //tileLayer.on('postcompose', function () {
        //    console.log('postcompose');
        //});

        //map.once('postrender', function () {
        //    console.log('post render');
        //});
        //map.once('rendercomplete', function () {
        //    console.log('render complete');
        //    startAnimation();
        //});

        var moveObjects = { index: 0 };

        function moveMarker() {

            var waypoints = waypointsWithIntermidiate;

            //         var point = new ol.source.Vector(
            //     new ol.geometry.Point(-111.04, 45.68));

            // var layer = new ol.source.Vector("My Layer", {
            //     style: ol.feature.Vector.style["default"]
            // });

            // map.addLayer(layer);
            // layer.addFeatures([point]);


            if (moveObjects.vectorContext && moveObjects.frameState) {
                //vectorLayer.destroyFeatures();
                //var elapsedTime = moveObjects.frameState.time - now;
                //console.log('here', elapsedTime)

                // here the trick to increase speed is to jump some indexes
                // on lineString coordinates
                //var index = Math.round(speed * elapsedTime / 1000);

                if (moveObjects.index >= waypoints.length) {
                    // TODO
                    stopAnimation(true);
                    return;
                }

                var waypointCoords = waypoints[moveObjects.index];
                var currentPoint = new ol.geom.Point(waypointCoords);
                var feature = new ol.Feature(currentPoint);
                //var text = inputData[moveObjects.index].Speed;
                var text = intermidiateWaypointsToOriginalData[waypointCoords[0] + waypointCoords[1]].Speed;
                styles.geoMarker.setText(createTextStyle(text));
                moveObjects.vectorContext.drawFeature(feature, styles.geoMarker);

                moveObjects.index += 1;
            }
        }

        //setInterval(function () {
        //    if (document.getElementById('completestate').innerHTML != 'yes') {
        //        moveMarker();
        //    }
        //}, 100);

        var moveFeature = function (event) {
            //console.log(event);
            var vectorContext = event.vectorContext;
            var frameState = event.frameState;

            moveObjects.vectorContext = event.vectorContext;
            moveObjects.frameState = event.frameState;

            //console.log('moveFeature');

            // tell OpenLayers to continue the postcompose animation
            //map.render();
        };

        function startAnimation() {
            document.getElementById('completestate').innerHTML = 'start';
            if (animating) {
                //stopAnimation(false);
            } else {
                animating = true;
                now = new Date().getTime();
                speed = 50;//speedInput.value;
                //startButton.textContent = 'Cancel Animation';
                // hide geoMarker
                geoMarker.setStyle(null);

                //// just in case you pan somewhere else
                //map.getView().setCenter(center);

                map.on('postcompose', moveFeature);
                map.render();
            }
        }

        function stopAnimation(ended) {
            document.getElementById('completestate').innerHTML = 'yes';
            console.log('animation complete');
            animating = false;

            //remove listener
            map.un('postcompose', moveFeature);
        }

        function fitMap() {
            var extent = {
                maxLng: Math.max.apply(null, wp.map(function (item) {
                    return item[0];
                })),
                minLng: Math.min.apply(null, wp.map(function (item) {
                    return item[0];
                })),
                maxLat: Math.max.apply(null, wp.map(function (item) {
                    return item[1];
                })),
                minLat: Math.min.apply(null, wp.map(function (item) {
                    return item[1];
                }))
            };
            view.fit([extent.minLng, extent.minLat, extent.maxLng, extent.maxLat]);
        }

        function distanceBetweenPoints(latlng1, latlng2) {
            var line = new ol.geom.LineString([latlng1, latlng2]);
            return line.getLength();
        };

        function createTextStyle(text) {
            return new ol.style.Text({
                textBaseline: 'middle',
                font: 'Arial',
                text: text,
                fill: new ol.style.Fill({ color: '#000000' }),
                offsetY: -15
            });
        };

    </script>
</body>
</html>
