@model IEnumerable<Example.CaptureMapMarkerMovements.Models.Waypoint>

@{
    ViewBag.Title = "Home Page";
    Layout = null;
    string jsonData = Newtonsoft.Json.JsonConvert.SerializeObject(Model);
}

<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://openlayers.org/en/v5.3.0/css/ol.css" type="text/css">
    <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.3.0/build/ol.js"></script>
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
</head>
<body>

    <div id="map" class="map" style="width: 1000px; height: 600px;"></div>
    <div id="completestate" style="display:none">not started</div>
    <div id="input-data" style="display:none">@jsonData</div>

    <script>        

        var inputData = JSON.parse(document.getElementById('input-data').innerText);

        var wp = [];
        for (var i = 0; i < inputData.length; i++) {
            wp.push([inputData[i].Lng, inputData[i].Lat]);
        }

        for (var i = 0; i < wp.length; i++) {
            wp[i] = ol.proj.fromLonLat(wp[i]);
        }

        var wpfeatureLine = new ol.Feature({
            geometry: new ol.geom.LineString(wp),
            name: 'ABC Line'
        });

        var wpline = new ol.source.Vector({});

        //Add point feature for every coordinate
        for (var i = 0; i < wp.length; i++) {
            //wp[i] = ol.proj.fromLonLat(wp[i]);
            //coord = wp[i];
            //var coord = ol.proj.fromLonLat(wp[i]);
            var pointFeature = new ol.Feature({
                geometry: new ol.geom.Point(wp[i]),
                name: 'XYZ' + i
            });
            wpline.addFeature(pointFeature);
        }

        //wpfeatureLine.setStyle(); You can add your custom style definition here.
        wpline.addFeature(wpfeatureLine); //lined or a way point feature on map

        var vectorLineLayer = new ol.layer.Vector({
            source: wpline,
            //Remove any style, Default style will be used
        });

        //var route = (new ol.format.Polyline({
        //    factor: 1e6
        //}).readGeometry(polyline, {
        //    dataProjection: 'EPSG:4326',
        //    featureProjection: 'EPSG:3857'
        //}));

        //var routeCoords = route.getCoordinates();
        //var routeLength = routeCoords.length;

        //var routeFeature = new ol.Feature({
        //    type: 'route',
        //    geometry: route
        //});
        var geoMarker = new ol.Feature({
            type: 'geoMarker',
            geometry: new ol.geom.Point(wp[0])
        });
        //var startMarker = new ol.Feature({
        //    type: 'icon',
        //    geometry: new ol.geom.Point(routeCoords[0])
        //});
        //var endMarker = new ol.Feature({
        //    type: 'icon',
        //    geometry: new ol.geom.Point(routeCoords[routeLength - 1])
        //});

        var styles = {
            'route': new ol.style.Style({
                stroke: new ol.style.Stroke({
                    width: 6, color: [237, 212, 0, 0.8]
                })
            }),
            'icon': new ol.style.Style({
                image: new ol.style.Icon({
                    anchor: [0.5, 1],
                    src: 'data/icon.png'
                })
            }),
            'geoMarker': new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({ color: 'black' }),
                    stroke: new ol.style.Stroke({
                        color: 'white', width: 2
                    })
                })
            })
        };

        var animating = false;
        var speed, now;
        var speedInput = document.getElementById('speed');
        var startButton = document.getElementById('start-animation');

        //var vectorLayer = new ol.layer.Vector({
        //    source: new ol.source.Vector({
        //        features: [routeFeature, geoMarker, startMarker, endMarker]
        //    }),
        //    style: function (feature) {
        //        // hide geoMarker if animation is active
        //        if (animating && feature.get('type') === 'geoMarker') {
        //            return null;
        //        }
        //        return styles[feature.get('type')];
        //    }
        //});

        var view = new ol.View({
            center: wp[0],
            zoom: 10,
            minZoom: 2,
            maxZoom: 19
        });

        var key = 'AifUA41UximrujvNoJp15-yQsmBOattJxjecWXdsW4fzIDr14uBd0-xvZykxDoAq';

        //var tileSource = new ol.source.OSM();
        var tileSource = new ol.source.BingMaps({ key: key, imagerySet: 'Road' })
        var tileLayer = new ol.layer.Tile({
            source: tileSource
        });

        var map = new ol.Map({
            target: document.getElementById('map'),
            loadTilesWhileAnimating: true,
            view: view,
            layers: [
                tileLayer,
                //vectorLayer,
                vectorLineLayer
            ],
            controls: []
        });

        fitMap();

        var tilesState = {
            loaded: 0,
            total: 0
        };
        tileSource.on('tileloadstart', function () {
            tilesState.total++;
            console.log('Tiles count: ' + tilesState.total);
        });
        tileSource.on('tileloadend', function (a) {
            tilesState.loaded++;
            if (tilesState.loaded == tilesState.total) {
                console.log('all tiles loaded');
                startAnimation();
            }            
        });
        tileSource.on('tileloaderror', function (a, b) {
            console.log('tile load error', a, b);
        });
        //tileLayer.on('postcompose', function () {
        //    console.log('postcompose');
        //});

        //map.once('postrender', function () {
        //    console.log('post render');
        //});
        //map.once('rendercomplete', function () {
        //    console.log('render complete');
        //    startAnimation();
        //});

        var moveObjects = { index: 0 };

        function moveMarker() {

            //         var point = new ol.source.Vector(
            //     new ol.geometry.Point(-111.04, 45.68));

            // var layer = new ol.source.Vector("My Layer", {
            //     style: ol.feature.Vector.style["default"]
            // });

            // map.addLayer(layer);
            // layer.addFeatures([point]);


            if (moveObjects.vectorContext && moveObjects.frameState) {
                //vectorLayer.destroyFeatures();
                //var elapsedTime = moveObjects.frameState.time - now;
                //console.log('here', elapsedTime)

                // here the trick to increase speed is to jump some indexes
                // on lineString coordinates
                //var index = Math.round(speed * elapsedTime / 1000);

                if (moveObjects.index >= wp.length) {
                    // TODO
                    stopAnimation(true);
                    return;
                }

                console.log(moveObjects.index);
                var currentPoint = new ol.geom.Point(wp[moveObjects.index]);
                moveObjects.index += 5;
                var feature = new ol.Feature(currentPoint);
                moveObjects.vectorContext.drawFeature(feature, styles.geoMarker);
            }
        }

         setInterval(function () {
           moveMarker();
         }, 100);

        var moveFeature = function (event) {
            //console.log(event);
            var vectorContext = event.vectorContext;
            var frameState = event.frameState;

            moveObjects.vectorContext = event.vectorContext;
            moveObjects.frameState = event.frameState;

            //console.log('moveFeature');

            // tell OpenLayers to continue the postcompose animation
            //map.render();
        };

        function startAnimation() {
            document.getElementById('completestate').innerHTML = 'start';
            if (animating) {
                //stopAnimation(false);
            } else {
                animating = true;
                now = new Date().getTime();
                speed = 50;//speedInput.value;
                //startButton.textContent = 'Cancel Animation';
                // hide geoMarker
                geoMarker.setStyle(null);

                //// just in case you pan somewhere else
                //map.getView().setCenter(center);

                map.on('postcompose', moveFeature);
                map.render();
            }
        }

        function stopAnimation(ended) {
            document.getElementById('completestate').innerHTML = 'yes';
            console.log('animation complete');
            animating = false;

            //remove listener
            map.un('postcompose', moveFeature);
        }

        function fitMap() {
            var extent = {
                maxLng: Math.max.apply(null, wp.map(function (item) {
                    return item[0];
                })),
                minLng: Math.min.apply(null, wp.map(function (item) {
                    return item[0];
                })),
                maxLat: Math.max.apply(null, wp.map(function (item) {
                    return item[1];
                })),
                minLat: Math.min.apply(null, wp.map(function (item) {
                    return item[1];
                }))
            };
            view.fit([extent.minLng, extent.minLat, extent.maxLng, extent.maxLat]);
        }

    </script>
</body>
</html>
